{"version":3,"sources":["main.js","processor.js","applier.js","intervalMaker.js","solver.js","tester.js","welder.js"],"names":["process","array","identify","map","item","index","processedItem","begin","end","type","id","apply","obj","solution","insert","length","ruler","JSON","parse","stringify","segmentIndex","findIndex","segment","removeSegment","splice","push","makeInterval","solve","conflict","interval","name","typeMismatch","create","Error","message","about","equal","hit","symbol","cover","coverLeft","dummy","coverRight","inside","insideLeft","insideRight","overlapLeft","overlapRight","outsideLeft","outsideRight","tests","names","Object","keys","test","some","weld","weldedRuler","shift","reduce","accumulator","intalg","intervals","sort","sortRuler","a","b","unshift","module","exports"],"mappings":"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","file":"intalg.js","sourcesContent":["import apply from './applier'\nimport process from './processor'\nimport solve from './solver'\nimport test from './tester'\nimport weld from './welder'\n\nexport default function intalg (obj) {\n\n  const intervals = process(obj.intervals)\n  let ruler = process(obj.ruler, true)\n\n  if (intervals.length === 0) {\n\n    ruler.sort(function sortRuler (a, b) {\n\n      return a.begin - b.begin\n\n    })\n\n    return process(weld({ ruler }))\n\n  }\n\n  const interval = intervals.shift()\n\n  let conflict\n  ruler.some(function (segment) {\n\n    conflict = test({ interval, segment })\n    return conflict\n\n  })\n\n  if (conflict) {\n\n    const solution = solve(conflict)\n    ruler = apply({ solution, ruler })\n    intervals.unshift(...solution.create)\n\n  } else {\n\n    ruler.push(interval)\n\n  }\n\n  return intalg({ intervals, ruler })\n\n}\n","export default function process (array, identify) {\n\n  return array.map(function (item, index) {\n\n    const processedItem = { begin: item.begin, end: item.end, type: item.type }\n\n    if (identify) {\n\n      processedItem.id = index\n\n    } else {\n\n      delete processedItem.id\n\n    }\n\n    return processedItem\n\n  })\n\n}\n","import process from './processor'\n\nexport default function apply (obj) {\n\n  if (obj.solution.insert.length === 0) return obj.ruler\n\n  const solution = JSON.parse(JSON.stringify(obj.solution))\n  const ruler = process(obj.ruler, true)\n\n  const segmentIndex = ruler.findIndex(function (segment) {\n\n    return segment.id === solution.removeSegment\n\n  })\n\n  if (segmentIndex > -1) {\n\n    ruler.splice(segmentIndex, 1)\n\n  }\n\n  ruler.push(...solution.insert)\n\n  return ruler\n\n}\n","export default function makeInterval (begin, end, type) {\n\n  return { begin, end, type }\n\n}\n","import makeInterval from './intervalMaker'\n\nexport default function solve (conflict) {\n\n  const { interval, name, segment, typeMismatch } = conflict\n  const solution = { create: [], insert: [], removeSegment: false }\n\n  if (typeMismatch) {\n\n    solution.removeSegment = segment.id\n\n  }\n\n  switch (name) {\n    case 'equal':\n      if (typeMismatch) {\n\n        solution.insert.push(\n          makeInterval(interval.begin, interval.end, interval.type)\n        )\n\n      }\n      break\n\n    case 'cover':\n      if (typeMismatch) {\n\n        solution.insert.push(\n          makeInterval(segment.begin, segment.end, interval.type)\n        )\n\n      }\n      solution.create.push(\n        makeInterval(interval.begin, segment.begin, interval.type),\n        makeInterval(segment.end, interval.end, interval.type)\n      )\n      break\n\n    case 'coverLeft':\n      if (typeMismatch) {\n\n        solution.insert.push(\n          makeInterval(interval.begin, segment.end, interval.type)\n        )\n\n      }\n      solution.create.push(\n        makeInterval(segment.end, interval.end, interval.type)\n      )\n      break\n\n    case 'coverRight':\n      if (typeMismatch) {\n\n        solution.insert.push(\n          makeInterval(segment.begin, interval.end, interval.type)\n        )\n\n      }\n      solution.create.push(\n        makeInterval(interval.begin, segment.begin, interval.type)\n      )\n      break\n\n    case 'inside':\n      if (typeMismatch) {\n\n        solution.insert.push(\n          makeInterval(interval.begin, interval.end, interval.type)\n        )\n        solution.create.push(\n          makeInterval(segment.begin, interval.begin, segment.type),\n          makeInterval(interval.end, segment.end, segment.type)\n        )\n\n      }\n      break\n\n    case 'insideLeft':\n      if (typeMismatch) {\n\n        solution.insert.push(\n          makeInterval(interval.begin, interval.end, interval.type)\n        )\n        solution.create.push(\n          makeInterval(interval.end, segment.end, segment.type)\n        )\n\n      }\n      break\n\n    case 'insideRight':\n      if (typeMismatch) {\n\n        solution.insert.push(\n          makeInterval(interval.begin, interval.end, interval.type)\n        )\n        solution.create.push(\n          makeInterval(segment.begin, interval.begin, segment.type)\n        )\n\n      }\n      break\n\n    case 'overlapLeft':\n      if (typeMismatch) {\n\n        solution.insert.push(\n          makeInterval(segment.begin, interval.end, interval.type)\n        )\n        solution.create.push(\n          makeInterval(interval.end, segment.end, segment.type)\n        )\n\n      }\n      solution.create.push(\n        makeInterval(interval.begin, segment.begin, interval.type)\n      )\n      break\n\n    case 'overlapRight':\n      if (typeMismatch) {\n\n        solution.insert.push(\n          makeInterval(interval.begin, segment.end, interval.type)\n        )\n        solution.create.push(\n          makeInterval(segment.begin, interval.begin, segment.type)\n        )\n\n      }\n      solution.create.push(\n        makeInterval(segment.end, interval.end, interval.type)\n      )\n      break\n    default:\n      throw new Error({ message: `INVALID CONFLICT NAME: ${name}` })\n\n  }\n\n  return solution\n\n}\n","const about = {\n  equal: { hit: true, name: 'equal', symbol: '<-------<\\n<-------<' },\n  cover: { hit: true, name: 'cover', symbol: '<---------<\\n <-------< ' },\n  coverLeft: {\n    hit: true,\n    name: 'coverLeft',\n    symbol: '<---------<\\n<--------< ',\n    dummy: true\n  },\n  coverRight: {\n    hit: true,\n    name: 'coverRight',\n    symbol: '<---------<\\n <--------<'\n  },\n  inside: { hit: true, name: 'inside', symbol: ' <-------< \\n<---------<' },\n  insideLeft: {\n    hit: true,\n    name: 'insideLeft',\n    symbol: '<--------< \\n<---------<'\n  },\n  insideRight: {\n    hit: true,\n    name: 'insideRight',\n    symbol: ' <--------<\\n<---------<'\n  },\n  overlapLeft: {\n    hit: true,\n    name: 'overlapLeft',\n    symbol: '<---------<\\n     <---------<'\n  },\n  overlapRight: {\n    hit: true,\n    name: 'overlapRight',\n    symbol: '     <---------<\\n<---------<'\n  },\n  outsideLeft: {\n    hit: false,\n    name: 'outsideLeft',\n    symbol: '<---------<\\n           <---------<'\n  },\n  outsideRight: {\n    hit: false,\n    name: 'outsideRight',\n    symbol: '           <---------<\\n<---------<'\n  }\n}\n\nconst tests = {\n  equal (interval, segment) {\n\n    return interval.begin === segment.begin && interval.end === segment.end\n\n  },\n  cover (interval, segment) {\n\n    return interval.begin < segment.begin && interval.end > segment.end\n\n  },\n  coverLeft (interval, segment) {\n\n    return interval.begin === segment.begin && interval.end > segment.end\n\n  },\n  coverRight (interval, segment) {\n\n    return interval.begin < segment.begin && interval.end === segment.end\n\n  },\n  inside (interval, segment) {\n\n    return interval.begin > segment.begin && interval.end < segment.end\n\n  },\n  insideLeft (interval, segment) {\n\n    return interval.begin === segment.begin && interval.end < segment.end\n\n  },\n  insideRight (interval, segment) {\n\n    return interval.begin > segment.begin && interval.end === segment.end\n\n  },\n  overlapLeft (interval, segment) {\n\n    return interval.begin < segment.begin &&\n      interval.end > segment.begin &&\n      interval.end < segment.end &&\n      interval.end > segment.begin\n\n  },\n  overlapRight (interval, segment) {\n\n    return interval.begin > segment.begin &&\n      interval.end > segment.end &&\n      interval.begin < segment.end &&\n      interval.end > segment.end\n\n  }\n}\n\nconst names = Object.keys(tests)\n\nexport default function test (obj) {\n\n  const interval = JSON.parse(JSON.stringify(obj.interval))\n  const segment = JSON.parse(JSON.stringify(obj.segment))\n\n  let conflict = false\n  names.some(function (name) {\n\n    const hit = tests[name](interval, segment)\n    if (hit) {\n\n      conflict = {\n        interval,\n        name,\n        segment,\n        typeMismatch: interval.type !== segment.type,\n        about: about[name]\n      }\n\n    }\n    return hit\n\n  })\n  return conflict\n\n}\n","import process from './processor'\n\nexport default function weld (obj) {\n\n  const ruler = process(obj.ruler)\n  const weldedRuler = [ ruler.shift() ]\n\n  ruler.reduce(\n    function (accumulator, interval) {\n\n      const segment = accumulator[accumulator.length - 1]\n      if (segment.end === interval.begin && segment.type === interval.type) {\n\n        segment.end = interval.end\n\n      } else {\n\n        accumulator.push(interval)\n\n      }\n      return accumulator\n\n    },\n    weldedRuler\n  )\n\n  return weldedRuler\n\n}\n"]}